<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Borrione Racing Arcade</title>
    <style>
        body { margin: 0; padding: 0; overflow: hidden; background: #222; font-family: sans-serif; }
        canvas { display: block; background: #333; margin: 0 auto; image-rendering: pixelated; }
        #ui { position: absolute; top: 10px; left: 10px; color: white; font-weight: bold; text-shadow: 2px 2px 0#000; pointer-events: none; }
    </style>
</head>
<body>

<div id="ui">
    PUNTOS: <span id="score">0</span><br>
    NEAR MISS: <span id="nearMiss">0</span>
</div>
<canvas id="gameCanvas"></canvas>

<script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const scoreElement = document.getElementById('score');
    const nearMissElement = document.getElementById('nearMiss');

    // CONFIGURACIÓN
    let score = 0;
    let nearMissCount = 0;
    let gameSpeed = 5;

    // FIX 2: Ajuste de resolución dinámica para el Xiaomi
    function resize() {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
    }
    window.addEventListener('resize', resize);
    resize();

    // CARGA DE IMÁGENES (Con sistema de verificación)
    const assets = {
        player: new Image(),
        enemy: new Image()
    };

    // Reemplaza estos nombres con los tuyos exactos si son diferentes
    assets.player.src = 'auto.png'; 
    assets.enemy.src = 'enemigo.png'; // Si no tenés, se dibujará un cuadro rojo

    let imagesLoaded = 0;
    assets.player.onload = () => imagesLoaded++;
    assets.enemy.onload = () => imagesLoaded++;

    // OBJETOS DEL JUEGO
    const player = {
        x: canvas.width / 2 - 25,
        y: canvas.height - 120,
        w: 50,
        h: 90,
        speed: 7
    };

    const obstacles = [];

    // LÓGICA DE MOVIMIENTO TÁCTIL (Para jugar en el cel)
    let touchX = player.x;
    window.addEventListener('touchmove', (e) => {
        touchX = e.touches[0].clientX - player.w / 2;
        // Evita que el auto se salga de la calle
        if(touchX < 20) touchX = 20;
        if(touchX > canvas.width - player.w - 20) touchX = canvas.width - player.w - 20;
    }, {passive: false});

    function spawnObstacle() {
        const x = Math.random() * (canvas.width - 70) + 20;
        obstacles.push({ x: x, y: -100, w: 50, h: 90, passed: false });
    }

    // LOOP PRINCIPAL (FIX 3: Optimización de FPS para evitar lag)
    function update() {
        // Mover jugador suavemente hacia el toque
        player.x += (touchX - player.x) * 0.2;

        // Mover obstáculos
        for (let i = obstacles.length - 1; i >= 0; i--) {
            let obs = obstacles[i];
            obs.y += gameSpeed;

            // --- LÓGICA DE NEAR MISS ---
            // Si el auto pasa cerca (distancia < 40) pero no choca
            let distX = Math.abs((player.x + player.w/2) - (obs.x + obs.w/2));
            let distY = Math.abs((player.y + player.h/2) - (obs.y + obs.h/2));

            if (!obs.passed && distY < 50 && distX < 80 && distX > 45) {
                nearMissCount++;
                nearMissElement.innerText = nearMissCount;
                obs.passed = true; // Solo contar una vez por auto
            }

            // Colisión básica
            if (player.x < obs.x + obs.w && player.x + player.w > obs.x &&
                player.y < obs.y + obs.h && player.y + player.h > obs.y) {
                // Reiniciar juego si choca
                score = 0;
                nearMissCount = 0;
                obstacles.length = 0;
                scoreElement.innerText = "0";
                nearMissElement.innerText = "0";
                gameSpeed = 5;
            }

            // Eliminar si sale de pantalla
            if (obs.y > canvas.height) {
                obstacles.splice(i, 1);
                score += 10;
                scoreElement.innerText = score;
                if(score % 100 === 0) gameSpeed += 0.5; // Sube dificultad
            }
        }

        if (Math.random() < 0.02) spawnObstacle();
    }

    function draw() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        // Dibujar Calle (Fondo simple)
        ctx.fillStyle = "#555";
        ctx.fillRect(20, 0, canvas.width - 40, canvas.height);
        
        // Líneas de la calle
        ctx.strokeStyle = "white";
        ctx.setLineDash([20, 20]);
        ctx.beginPath();
        ctx.moveTo(canvas.width / 2, 0);
        ctx.lineTo(canvas.width / 2, canvas.height);
        ctx.stroke();

        // Dibujar Jugador
        if (imagesLoaded >= 1) {
            ctx.drawImage(assets.player, player.x, player.y, player.h, player.h);
        } else {
            ctx.fillStyle = "blue";
            ctx.fillRect(player.x, player.y, player.w, player.h);
        }

        // Dibujar Enemigos
        obstacles.forEach(obs => {
            if (imagesLoaded >= 2) {
                ctx.drawImage(assets.enemy, obs.x, obs.y, obs.w, obs.h);
            } else {
                ctx.fillStyle = "red";
                ctx.fillRect(obs.x, obs.y, obs.w, obs.h);
            }
        });
    }

    function gameLoop() {
        update();
        draw();
        requestAnimationFrame(gameLoop); // ELIMINA EL LAG
    }

    gameLoop();
</script>
</body>
</html>

